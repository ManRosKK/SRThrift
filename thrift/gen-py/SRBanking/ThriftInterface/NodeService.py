#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8string,new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def makeTransfer(self, receiver, value):
    """


    Parameters:
     - receiver
     - value
    """
    pass

  def getAccountBalance(self):
    """

    """
    pass

  def ping(self, sender):
    """
    pings node

    Parameters:
     - sender
    """
    pass

  def pingSwarm(self, sender, transfer):
    """
    pings Swarm and checks if sender is a leader

    Parameters:
     - sender
     - transfer
    """
    pass

  def updateSwarmMembers(self, sender, swarm):
    """
      

    Parameters:
     - sender
     - swarm
    """
    pass

  def addToSwarm(self, sender, swarm, transferData):
    """


    Parameters:
     - sender
     - swarm
     - transferData
    """
    pass

  def delSwarm(self, sender, swarmID):
    """


    Parameters:
     - sender
     - swarmID
    """
    pass

  def getSwarm(self, sender, transfer):
    """


    Parameters:
     - sender
     - transfer
    """
    pass

  def electSwarmLeader(self, sender, cadidate, Transfer):
    """
    returns true if candidateNodeID> current

    Parameters:
     - sender
     - cadidate
     - Transfer
    """
    pass

  def electionEndedSwarm(self, sender, swarm):
    """
    new leader broadcast that he is a leader

    Parameters:
     - sender
     - swarm
    """
    pass

  def deliverTransfer(self, sender, transfer):
    """


    Parameters:
     - sender
     - transfer
    """
    pass

  def getSwarmList(self):
    """
    DEBUG
    """
    pass

  def startSwarmElection(self, transfer):
    """
    Parameters:
     - transfer
    """
    pass

  def getTransfers(self):
    pass

  def setBlacklist(self, blacklist):
    """
    It sets "blacklist" - list of nodes which are not accessible (in both directions) for the callee

    Parameters:
     - blacklist
    """
    pass

  def virtualStop(self, shouldStop):
    """
    The method simulates killing server - all non-debug methods should fail (maybe except getSwarm getAccountBalance)

    Parameters:
     - shouldStop
    """
    pass

  def stop(self):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def makeTransfer(self, receiver, value):
    """


    Parameters:
     - receiver
     - value
    """
    self.send_makeTransfer(receiver, value)
    self.recv_makeTransfer()

  def send_makeTransfer(self, receiver, value):
    self._oprot.writeMessageBegin('makeTransfer', TMessageType.CALL, self._seqid)
    args = makeTransfer_args()
    args.receiver = receiver
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_makeTransfer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = makeTransfer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    if result.exc2 is not None:
      raise result.exc2
    return

  def getAccountBalance(self):
    """

    """
    self.send_getAccountBalance()
    return self.recv_getAccountBalance()

  def send_getAccountBalance(self):
    self._oprot.writeMessageBegin('getAccountBalance', TMessageType.CALL, self._seqid)
    args = getAccountBalance_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAccountBalance(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAccountBalance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAccountBalance failed: unknown result");

  def ping(self, sender):
    """
    pings node

    Parameters:
     - sender
    """
    self.send_ping(sender)
    self.recv_ping()

  def send_ping(self, sender):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.sender = sender
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def pingSwarm(self, sender, transfer):
    """
    pings Swarm and checks if sender is a leader

    Parameters:
     - sender
     - transfer
    """
    self.send_pingSwarm(sender, transfer)
    self.recv_pingSwarm()

  def send_pingSwarm(self, sender, transfer):
    self._oprot.writeMessageBegin('pingSwarm', TMessageType.CALL, self._seqid)
    args = pingSwarm_args()
    args.sender = sender
    args.transfer = transfer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingSwarm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = pingSwarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    return

  def updateSwarmMembers(self, sender, swarm):
    """
      

    Parameters:
     - sender
     - swarm
    """
    self.send_updateSwarmMembers(sender, swarm)
    self.recv_updateSwarmMembers()

  def send_updateSwarmMembers(self, sender, swarm):
    self._oprot.writeMessageBegin('updateSwarmMembers', TMessageType.CALL, self._seqid)
    args = updateSwarmMembers_args()
    args.sender = sender
    args.swarm = swarm
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateSwarmMembers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateSwarmMembers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    if result.exc2 is not None:
      raise result.exc2
    return

  def addToSwarm(self, sender, swarm, transferData):
    """


    Parameters:
     - sender
     - swarm
     - transferData
    """
    self.send_addToSwarm(sender, swarm, transferData)
    self.recv_addToSwarm()

  def send_addToSwarm(self, sender, swarm, transferData):
    self._oprot.writeMessageBegin('addToSwarm', TMessageType.CALL, self._seqid)
    args = addToSwarm_args()
    args.sender = sender
    args.swarm = swarm
    args.transferData = transferData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addToSwarm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addToSwarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    return

  def delSwarm(self, sender, swarmID):
    """


    Parameters:
     - sender
     - swarmID
    """
    self.send_delSwarm(sender, swarmID)
    self.recv_delSwarm()

  def send_delSwarm(self, sender, swarmID):
    self._oprot.writeMessageBegin('delSwarm', TMessageType.CALL, self._seqid)
    args = delSwarm_args()
    args.sender = sender
    args.swarmID = swarmID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delSwarm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = delSwarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    if result.exc2 is not None:
      raise result.exc2
    return

  def getSwarm(self, sender, transfer):
    """


    Parameters:
     - sender
     - transfer
    """
    self.send_getSwarm(sender, transfer)
    return self.recv_getSwarm()

  def send_getSwarm(self, sender, transfer):
    self._oprot.writeMessageBegin('getSwarm', TMessageType.CALL, self._seqid)
    args = getSwarm_args()
    args.sender = sender
    args.transfer = transfer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSwarm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSwarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exc is not None:
      raise result.exc
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSwarm failed: unknown result");

  def electSwarmLeader(self, sender, cadidate, Transfer):
    """
    returns true if candidateNodeID> current

    Parameters:
     - sender
     - cadidate
     - Transfer
    """
    self.send_electSwarmLeader(sender, cadidate, Transfer)
    return self.recv_electSwarmLeader()

  def send_electSwarmLeader(self, sender, cadidate, Transfer):
    self._oprot.writeMessageBegin('electSwarmLeader', TMessageType.CALL, self._seqid)
    args = electSwarmLeader_args()
    args.sender = sender
    args.cadidate = cadidate
    args.Transfer = Transfer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_electSwarmLeader(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = electSwarmLeader_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exc is not None:
      raise result.exc
    raise TApplicationException(TApplicationException.MISSING_RESULT, "electSwarmLeader failed: unknown result");

  def electionEndedSwarm(self, sender, swarm):
    """
    new leader broadcast that he is a leader

    Parameters:
     - sender
     - swarm
    """
    self.send_electionEndedSwarm(sender, swarm)
    self.recv_electionEndedSwarm()

  def send_electionEndedSwarm(self, sender, swarm):
    self._oprot.writeMessageBegin('electionEndedSwarm', TMessageType.CALL, self._seqid)
    args = electionEndedSwarm_args()
    args.sender = sender
    args.swarm = swarm
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_electionEndedSwarm(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = electionEndedSwarm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    return

  def deliverTransfer(self, sender, transfer):
    """


    Parameters:
     - sender
     - transfer
    """
    self.send_deliverTransfer(sender, transfer)
    self.recv_deliverTransfer()

  def send_deliverTransfer(self, sender, transfer):
    self._oprot.writeMessageBegin('deliverTransfer', TMessageType.CALL, self._seqid)
    args = deliverTransfer_args()
    args.sender = sender
    args.transfer = transfer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deliverTransfer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deliverTransfer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def getSwarmList(self):
    """
    DEBUG
    """
    self.send_getSwarmList()
    return self.recv_getSwarmList()

  def send_getSwarmList(self):
    self._oprot.writeMessageBegin('getSwarmList', TMessageType.CALL, self._seqid)
    args = getSwarmList_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSwarmList(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSwarmList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSwarmList failed: unknown result");

  def startSwarmElection(self, transfer):
    """
    Parameters:
     - transfer
    """
    self.send_startSwarmElection(transfer)
    self.recv_startSwarmElection()

  def send_startSwarmElection(self, transfer):
    self._oprot.writeMessageBegin('startSwarmElection', TMessageType.CALL, self._seqid)
    args = startSwarmElection_args()
    args.transfer = transfer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startSwarmElection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startSwarmElection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exc is not None:
      raise result.exc
    return

  def getTransfers(self):
    self.send_getTransfers()
    return self.recv_getTransfers()

  def send_getTransfers(self):
    self._oprot.writeMessageBegin('getTransfers', TMessageType.CALL, self._seqid)
    args = getTransfers_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTransfers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTransfers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTransfers failed: unknown result");

  def setBlacklist(self, blacklist):
    """
    It sets "blacklist" - list of nodes which are not accessible (in both directions) for the callee

    Parameters:
     - blacklist
    """
    self.send_setBlacklist(blacklist)
    self.recv_setBlacklist()

  def send_setBlacklist(self, blacklist):
    self._oprot.writeMessageBegin('setBlacklist', TMessageType.CALL, self._seqid)
    args = setBlacklist_args()
    args.blacklist = blacklist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setBlacklist(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setBlacklist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def virtualStop(self, shouldStop):
    """
    The method simulates killing server - all non-debug methods should fail (maybe except getSwarm getAccountBalance)

    Parameters:
     - shouldStop
    """
    self.send_virtualStop(shouldStop)
    self.recv_virtualStop()

  def send_virtualStop(self, shouldStop):
    self._oprot.writeMessageBegin('virtualStop', TMessageType.CALL, self._seqid)
    args = virtualStop_args()
    args.shouldStop = shouldStop
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_virtualStop(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = virtualStop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def stop(self):
    self.send_stop()
    self.recv_stop()

  def send_stop(self):
    self._oprot.writeMessageBegin('stop', TMessageType.CALL, self._seqid)
    args = stop_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stop(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["makeTransfer"] = Processor.process_makeTransfer
    self._processMap["getAccountBalance"] = Processor.process_getAccountBalance
    self._processMap["ping"] = Processor.process_ping
    self._processMap["pingSwarm"] = Processor.process_pingSwarm
    self._processMap["updateSwarmMembers"] = Processor.process_updateSwarmMembers
    self._processMap["addToSwarm"] = Processor.process_addToSwarm
    self._processMap["delSwarm"] = Processor.process_delSwarm
    self._processMap["getSwarm"] = Processor.process_getSwarm
    self._processMap["electSwarmLeader"] = Processor.process_electSwarmLeader
    self._processMap["electionEndedSwarm"] = Processor.process_electionEndedSwarm
    self._processMap["deliverTransfer"] = Processor.process_deliverTransfer
    self._processMap["getSwarmList"] = Processor.process_getSwarmList
    self._processMap["startSwarmElection"] = Processor.process_startSwarmElection
    self._processMap["getTransfers"] = Processor.process_getTransfers
    self._processMap["setBlacklist"] = Processor.process_setBlacklist
    self._processMap["virtualStop"] = Processor.process_virtualStop
    self._processMap["stop"] = Processor.process_stop

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_makeTransfer(self, seqid, iprot, oprot):
    args = makeTransfer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = makeTransfer_result()
    try:
      self._handler.makeTransfer(args.receiver, args.value)
    except NotEnoughMembersToMakeTransfer, exc:
      result.exc = exc
    except NotEnoughMoney, exc2:
      result.exc2 = exc2
    oprot.writeMessageBegin("makeTransfer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAccountBalance(self, seqid, iprot, oprot):
    args = getAccountBalance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAccountBalance_result()
    result.success = self._handler.getAccountBalance()
    oprot.writeMessageBegin("getAccountBalance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping(args.sender)
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingSwarm(self, seqid, iprot, oprot):
    args = pingSwarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingSwarm_result()
    try:
      self._handler.pingSwarm(args.sender, args.transfer)
    except NotSwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("pingSwarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateSwarmMembers(self, seqid, iprot, oprot):
    args = updateSwarmMembers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateSwarmMembers_result()
    try:
      self._handler.updateSwarmMembers(args.sender, args.swarm)
    except NotSwarmMemeber, exc:
      result.exc = exc
    except WrongSwarmLeader, exc2:
      result.exc2 = exc2
    oprot.writeMessageBegin("updateSwarmMembers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addToSwarm(self, seqid, iprot, oprot):
    args = addToSwarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addToSwarm_result()
    try:
      self._handler.addToSwarm(args.sender, args.swarm, args.transferData)
    except AlreadySwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("addToSwarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delSwarm(self, seqid, iprot, oprot):
    args = delSwarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delSwarm_result()
    try:
      self._handler.delSwarm(args.sender, args.swarmID)
    except NotSwarmMemeber, exc:
      result.exc = exc
    except WrongSwarmLeader, exc2:
      result.exc2 = exc2
    oprot.writeMessageBegin("delSwarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSwarm(self, seqid, iprot, oprot):
    args = getSwarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSwarm_result()
    try:
      result.success = self._handler.getSwarm(args.sender, args.transfer)
    except NotSwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("getSwarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_electSwarmLeader(self, seqid, iprot, oprot):
    args = electSwarmLeader_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = electSwarmLeader_result()
    try:
      result.success = self._handler.electSwarmLeader(args.sender, args.cadidate, args.Transfer)
    except NotSwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("electSwarmLeader", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_electionEndedSwarm(self, seqid, iprot, oprot):
    args = electionEndedSwarm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = electionEndedSwarm_result()
    try:
      self._handler.electionEndedSwarm(args.sender, args.swarm)
    except NotSwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("electionEndedSwarm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deliverTransfer(self, seqid, iprot, oprot):
    args = deliverTransfer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deliverTransfer_result()
    self._handler.deliverTransfer(args.sender, args.transfer)
    oprot.writeMessageBegin("deliverTransfer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSwarmList(self, seqid, iprot, oprot):
    args = getSwarmList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSwarmList_result()
    result.success = self._handler.getSwarmList()
    oprot.writeMessageBegin("getSwarmList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startSwarmElection(self, seqid, iprot, oprot):
    args = startSwarmElection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startSwarmElection_result()
    try:
      self._handler.startSwarmElection(args.transfer)
    except NotSwarmMemeber, exc:
      result.exc = exc
    oprot.writeMessageBegin("startSwarmElection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTransfers(self, seqid, iprot, oprot):
    args = getTransfers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTransfers_result()
    result.success = self._handler.getTransfers()
    oprot.writeMessageBegin("getTransfers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setBlacklist(self, seqid, iprot, oprot):
    args = setBlacklist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setBlacklist_result()
    self._handler.setBlacklist(args.blacklist)
    oprot.writeMessageBegin("setBlacklist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_virtualStop(self, seqid, iprot, oprot):
    args = virtualStop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = virtualStop_result()
    self._handler.virtualStop(args.shouldStop)
    oprot.writeMessageBegin("virtualStop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stop(self, seqid, iprot, oprot):
    args = stop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stop_result()
    self._handler.stop()
    oprot.writeMessageBegin("stop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class makeTransfer_args(object):
  """
  Attributes:
   - receiver
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'receiver', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.I64, 'value', None, None, ), # 2
  )

  def __init__(self, receiver=None, value=None,):
    self.receiver = receiver
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.receiver = NodeID()
          self.receiver.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.value = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('makeTransfer_args')
    if self.receiver is not None:
      oprot.writeFieldBegin('receiver', TType.STRUCT, 1)
      self.receiver.write(oprot)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I64, 2)
      oprot.writeI64(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class makeTransfer_result(object):
  """
  Attributes:
   - exc
   - exc2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotEnoughMembersToMakeTransfer, NotEnoughMembersToMakeTransfer.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'exc2', (NotEnoughMoney, NotEnoughMoney.thrift_spec), None, ), # 2
  )

  def __init__(self, exc=None, exc2=None,):
    self.exc = exc
    self.exc2 = exc2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotEnoughMembersToMakeTransfer()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.exc2 = NotEnoughMoney()
          self.exc2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('makeTransfer_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    if self.exc2 is not None:
      oprot.writeFieldBegin('exc2', TType.STRUCT, 2)
      self.exc2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccountBalance_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccountBalance_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccountBalance_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccountBalance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_args(object):
  """
  Attributes:
   - sender
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
  )

  def __init__(self, sender=None,):
    self.sender = sender

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingSwarm_args(object):
  """
  Attributes:
   - sender
   - transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transfer', (TransferID, TransferID.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, transfer=None,):
    self.sender = sender
    self.transfer = transfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transfer = TransferID()
          self.transfer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingSwarm_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.transfer is not None:
      oprot.writeFieldBegin('transfer', TType.STRUCT, 2)
      self.transfer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingSwarm_result(object):
  """
  Attributes:
   - exc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, exc=None,):
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingSwarm_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSwarmMembers_args(object):
  """
  Attributes:
   - sender
   - swarm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'swarm', (Swarm, Swarm.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, swarm=None,):
    self.sender = sender
    self.swarm = swarm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.swarm = Swarm()
          self.swarm.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSwarmMembers_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.swarm is not None:
      oprot.writeFieldBegin('swarm', TType.STRUCT, 2)
      self.swarm.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSwarmMembers_result(object):
  """
  Attributes:
   - exc
   - exc2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'exc2', (WrongSwarmLeader, WrongSwarmLeader.thrift_spec), None, ), # 2
  )

  def __init__(self, exc=None, exc2=None,):
    self.exc = exc
    self.exc2 = exc2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.exc2 = WrongSwarmLeader()
          self.exc2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSwarmMembers_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    if self.exc2 is not None:
      oprot.writeFieldBegin('exc2', TType.STRUCT, 2)
      self.exc2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addToSwarm_args(object):
  """
  Attributes:
   - sender
   - swarm
   - transferData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'swarm', (Swarm, Swarm.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transferData', (TransferData, TransferData.thrift_spec), None, ), # 3
  )

  def __init__(self, sender=None, swarm=None, transferData=None,):
    self.sender = sender
    self.swarm = swarm
    self.transferData = transferData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.swarm = Swarm()
          self.swarm.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transferData = TransferData()
          self.transferData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addToSwarm_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.swarm is not None:
      oprot.writeFieldBegin('swarm', TType.STRUCT, 2)
      self.swarm.write(oprot)
      oprot.writeFieldEnd()
    if self.transferData is not None:
      oprot.writeFieldBegin('transferData', TType.STRUCT, 3)
      self.transferData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addToSwarm_result(object):
  """
  Attributes:
   - exc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (AlreadySwarmMemeber, AlreadySwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, exc=None,):
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = AlreadySwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addToSwarm_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delSwarm_args(object):
  """
  Attributes:
   - sender
   - swarmID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'swarmID', (TransferID, TransferID.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, swarmID=None,):
    self.sender = sender
    self.swarmID = swarmID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.swarmID = TransferID()
          self.swarmID.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delSwarm_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.swarmID is not None:
      oprot.writeFieldBegin('swarmID', TType.STRUCT, 2)
      self.swarmID.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delSwarm_result(object):
  """
  Attributes:
   - exc
   - exc2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'exc2', (WrongSwarmLeader, WrongSwarmLeader.thrift_spec), None, ), # 2
  )

  def __init__(self, exc=None, exc2=None,):
    self.exc = exc
    self.exc2 = exc2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.exc2 = WrongSwarmLeader()
          self.exc2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delSwarm_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    if self.exc2 is not None:
      oprot.writeFieldBegin('exc2', TType.STRUCT, 2)
      self.exc2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSwarm_args(object):
  """
  Attributes:
   - sender
   - transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transfer', (TransferID, TransferID.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, transfer=None,):
    self.sender = sender
    self.transfer = transfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transfer = TransferID()
          self.transfer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSwarm_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.transfer is not None:
      oprot.writeFieldBegin('transfer', TType.STRUCT, 2)
      self.transfer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSwarm_result(object):
  """
  Attributes:
   - success
   - exc
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Swarm, Swarm.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exc=None,):
    self.success = success
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Swarm()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSwarm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class electSwarmLeader_args(object):
  """
  Attributes:
   - sender
   - cadidate
   - Transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'cadidate', (NodeID, NodeID.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'Transfer', (TransferID, TransferID.thrift_spec), None, ), # 3
  )

  def __init__(self, sender=None, cadidate=None, Transfer=None,):
    self.sender = sender
    self.cadidate = cadidate
    self.Transfer = Transfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.cadidate = NodeID()
          self.cadidate.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.Transfer = TransferID()
          self.Transfer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('electSwarmLeader_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.cadidate is not None:
      oprot.writeFieldBegin('cadidate', TType.STRUCT, 2)
      self.cadidate.write(oprot)
      oprot.writeFieldEnd()
    if self.Transfer is not None:
      oprot.writeFieldBegin('Transfer', TType.STRUCT, 3)
      self.Transfer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class electSwarmLeader_result(object):
  """
  Attributes:
   - success
   - exc
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exc=None,):
    self.success = success
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('electSwarmLeader_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class electionEndedSwarm_args(object):
  """
  Attributes:
   - sender
   - swarm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'swarm', (Swarm, Swarm.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, swarm=None,):
    self.sender = sender
    self.swarm = swarm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.swarm = Swarm()
          self.swarm.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('electionEndedSwarm_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.swarm is not None:
      oprot.writeFieldBegin('swarm', TType.STRUCT, 2)
      self.swarm.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class electionEndedSwarm_result(object):
  """
  Attributes:
   - exc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, exc=None,):
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('electionEndedSwarm_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deliverTransfer_args(object):
  """
  Attributes:
   - sender
   - transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sender', (NodeID, NodeID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transfer', (TransferData, TransferData.thrift_spec), None, ), # 2
  )

  def __init__(self, sender=None, transfer=None,):
    self.sender = sender
    self.transfer = transfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sender = NodeID()
          self.sender.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transfer = TransferData()
          self.transfer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deliverTransfer_args')
    if self.sender is not None:
      oprot.writeFieldBegin('sender', TType.STRUCT, 1)
      self.sender.write(oprot)
      oprot.writeFieldEnd()
    if self.transfer is not None:
      oprot.writeFieldBegin('transfer', TType.STRUCT, 2)
      self.transfer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deliverTransfer_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deliverTransfer_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSwarmList_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSwarmList_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSwarmList_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Swarm, Swarm.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Swarm()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSwarmList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startSwarmElection_args(object):
  """
  Attributes:
   - transfer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'transfer', (TransferID, TransferID.thrift_spec), None, ), # 1
  )

  def __init__(self, transfer=None,):
    self.transfer = transfer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.transfer = TransferID()
          self.transfer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startSwarmElection_args')
    if self.transfer is not None:
      oprot.writeFieldBegin('transfer', TType.STRUCT, 1)
      self.transfer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startSwarmElection_result(object):
  """
  Attributes:
   - exc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exc', (NotSwarmMemeber, NotSwarmMemeber.thrift_spec), None, ), # 1
  )

  def __init__(self, exc=None,):
    self.exc = exc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exc = NotSwarmMemeber()
          self.exc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startSwarmElection_result')
    if self.exc is not None:
      oprot.writeFieldBegin('exc', TType.STRUCT, 1)
      self.exc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTransfers_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTransfers_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTransfers_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TransferData, TransferData.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = TransferData()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTransfers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setBlacklist_args(object):
  """
  Attributes:
   - blacklist
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'blacklist', (TType.STRUCT,(NodeID, NodeID.thrift_spec)), None, ), # 1
  )

  def __init__(self, blacklist=None,):
    self.blacklist = blacklist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.blacklist = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = NodeID()
            _elem26.read(iprot)
            self.blacklist.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setBlacklist_args')
    if self.blacklist is not None:
      oprot.writeFieldBegin('blacklist', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.blacklist))
      for iter27 in self.blacklist:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setBlacklist_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setBlacklist_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class virtualStop_args(object):
  """
  Attributes:
   - shouldStop
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'shouldStop', None, None, ), # 1
  )

  def __init__(self, shouldStop=None,):
    self.shouldStop = shouldStop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.shouldStop = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('virtualStop_args')
    if self.shouldStop is not None:
      oprot.writeFieldBegin('shouldStop', TType.BOOL, 1)
      oprot.writeBool(self.shouldStop)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class virtualStop_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('virtualStop_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_result(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
